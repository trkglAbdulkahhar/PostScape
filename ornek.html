require('dotenv').config();

// 1. Imports
const express = require('express');
const mongoose = require('mongoose');
const session = require('express-session');
const MongoStore = require('connect-mongo');
const { engine } = require('express-handlebars');
const cookieParser = require('cookie-parser');
const path = require('path');
const http = require('http');
const { Server } = require('socket.io');
const isAuthenticated = require('./middleware/isAuth');

// 2. Database Connection
const connectDB = require('./config/db');
connectDB();

// 3. Model Registration (Critical)
require('./models/User');
require('./models/Post');
require('./models/Comment');

// Add this temporary startup script to app.js
const cleanGhosts = async () => {
try {
const User = require('./models/User');
const Post = require('./models/Post');

// 1. SLUG MIGRATION
const postsWithoutSlug = await Post.find({ slug: { $exists: false } });
if (postsWithoutSlug.length > 0) {
console.log(`ðŸŒ Migrating ${postsWithoutSlug.length} posts to slugs...`);
for (let post of postsWithoutSlug) {
// Pre-save hook will generate the slug
await post.save();
}
console.log("âœ… Slug migration complete.");
}

// 2. USER GHOST CLEANUP & SLUG MIGRATION
const users = await User.find();
const slugify = require('slugify');

for (let user of users) {
// SLUG GENERATION
if (!user.slug && user.nickname) {
user.slug = slugify(user.nickname, { lower: true, strict: true, locale: 'tr' });
await user.save({ validateBeforeSave: false });
}

// ... existing cleanup logic ...
if (user.interests && user.interests.length > 0 && typeof user.interests[0] === 'string' &&
user.interests[0].includes('{')) {
user.interests = [];
}

// Sadece gerÃ§ekten DB'de var olan postlarÄ± tut
const validLiked = [];
for (let id of user.likedPosts) {
const exists = await Post.exists({ _id: id });
if (exists) validLiked.push(id);
}

const validSaved = [];
for (let id of user.savedPosts) {
const exists = await Post.exists({ _id: id });
if (exists) validSaved.push(id);
}

user.likedPosts = validLiked;
user.savedPosts = validSaved;

await user.save({ validateBeforeSave: false });
}
} catch (err) {
console.error("Startup Script Error:", err);
}
};
cleanGhosts(); // Run on start

// Temporary Admin Promotion Script
const promoteAdmin = async () => {
try {
const User = require('./models/User');
await User.findOneAndUpdate({ email: 'tester@example.com' }, { role: 'admin' });
} catch (err) {
console.log('Hata:', err);
}
};
// promoteAdmin(); // Disabled to preserve 'Owner' role from fix_roles.js

// Initialize App
const app = express();
const server = http.createServer(app);
const io = new Server(server, { cors: { origin: '*' } });
app.set('io', io);

// 4. Middleware
app.use(express.urlencoded({ extended: false }));
app.use(express.json());
app.use(cookieParser());
app.use(express.static(path.join(__dirname, 'public')));
app.use('/uploads', express.static(path.join(__dirname, 'public/uploads')));

// Session
app.use(session({
secret: process.env.SESSION_SECRET || 'fallback_secret',
resave: false,
saveUninitialized: false,
store: MongoStore.create({
mongoUrl: process.env.MONGODB_URI,
collectionName: "sessions",
ttl: 24 * 60 * 60 // 1 day
}),
cookie: {
httpOnly: true,
secure: process.env.NODE_ENV === 'production',
maxAge: 1000 * 60 * 60 * 24 // 1 day
}
}));

// CSRF Protection
const csurf = require('csurf');
const csrfOptions = { cookie: { httpOnly: true, secure: process.env.NODE_ENV === 'production' } };
const csrfProtection = csurf(csrfOptions);
const csrfPermissive = csurf({ ...csrfOptions, ignoreMethods: ['GET', 'HEAD', 'OPTIONS', 'POST', 'PUT', 'DELETE'] });

// Dual CSRF Middleware
app.use((req, res, next) => {
const contentType = req.get('Content-Type');
if (contentType && contentType.startsWith('multipart/form-data')) {
// Multipart: Skip validation here (handled in route), but attach csrfToken function
csrfPermissive(req, res, next);
} else {
// Standard: Validate everything except GET/HEAD/OPTIONS
csrfProtection(req, res, next);
}
});

// Global CSRF Token Middleware
app.use((req, res, next) => {
// Now this will always work because one of the above middlewares definitely ran
res.locals.csrfToken = req.csrfToken();
next();
});

// CSRF Error Handler
app.use((err, req, res, next) => {
if (err.code !== 'EBADCSRFTOKEN') return next(err);
res.status(403);
res.send('GÃ¼venlik HatasÄ±: Form oturumunuz sona erdi. LÃ¼tfen sayfayÄ± yenileyip tekrar deneyin. (CSRF Error)');
});

// 5. View Engine
app.engine('.hbs', engine({
extname: '.hbs',
defaultLayout: 'main',
partialsDir: path.join(__dirname, 'views/partials'),
helpers: {
// NEW HELPER: Check if array includes value (Handles ObjectIds safely)
includes: function (array, value) {
if (!Array.isArray(array) || !value) return false;
return array.map(i => i.toString()).includes(value.toString());
},
// NEW HELPER: Check if message is editable (under 30 seconds)
isEditable: (createdAt) => {
const now = new Date();
const created = new Date(createdAt);
const diff = now - created;
return diff < 30000; // 30000 ms=30 seconds }, formatDate: function (date) { if (!date) return '' ; return new
    Date(date).toLocaleString([], { year: 'numeric' , month: 'numeric' , day: 'numeric' , hour: '2-digit' ,
    minute: '2-digit' }); }, // NEW HELPER: Check if message is editable (under 30 seconds) canEdit: function
    (createdAt) { const now=new Date(); const created=new Date(createdAt); const diff=now - created; return diff <
    30000; }, eq: function (a, b) { return String(a)===String(b); }, notEq: function (a, b) { return String(a)
    !==String(b); }, or: function (a, b) { return a || b; }, formatTime: (date)=> {
    const d = new Date(date);
    return `${d.getHours().toString().padStart(2, '0')}:${d.getMinutes().toString().padStart(2, '0')}`;
    },
    truncate: function (str, len) {
    if (str && str.length > len) {
    return str.substring(0, len - 3) + '...';
    }
    return str;
    },
    initials: function (name) {
    if (!name) return '??';
    return name.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();
    },
    toString: function (val) { return String(val); },
    // NEW HELPER: Check if user liked the post
    isLikedByUser: function (likesArray, userId) {
    if (!likesArray || !userId) return false;
    // likesArray iÃ§indeki her bir ID'yi stringe Ã§evirip kullanÄ±cÄ±nÄ±n ID'si ile kÄ±yaslar
    return likesArray.some(id => id.toString() === userId.toString());
    },
    isFollowing: function (userId, followersArray) {
    if (!userId || !followersArray) return false;
    return followersArray.some(id => id.toString() === userId.toString());
    },
    slugify: function (text) {
    if (!text) return '';
    const slugify = require('slugify'); // Require inside helper to ensure it's available
    return slugify(text, { lower: true, strict: true, locale: 'tr' });
    }
    }
    }));
    app.set('view engine', '.hbs');
    app.set('views', './views');

    // 6. Global Variables & Auth Logic


    // --- GLOBAL DATA MIDDLEWARE (The Fix) ---
    app.use(async (req, res, next) => {
    // Default locals
    res.locals.user = null;
    res.locals.currentUser = null; // Legacy Support
    res.locals.isAdmin = false;
    res.locals.isMaster = false;
    res.locals.collections = [];
    res.locals.onlineCount = 1;
    res.locals.savedPostIds = []; // Critical for the Icons

    if (req.session && req.session.user) {
    try {
    // 1. FRESH USER FETCH: Always get the latest data from DB
    const User = mongoose.model('User');
    const user = await User.findById(req.session.user._id).lean();

    if (user) {
    // Update session if needed (optional) but rely on local variable
    res.locals.user = user;
    res.locals.currentUser = user; // Backup

    // SYNC SESSION ROLE (Crucial for Auth Middleware)
    if (req.session.user.role !== user.role) {
    req.session.user.role = user.role;
    req.session.save(); // Ensure persistence
    }

    // Role Helpers
    res.locals.isAdmin = user.role === 'admin' || user.role === 'owner';
    res.locals.isMaster = user.role === 'owner';

    // Update Last Active
    await User.findByIdAndUpdate(user._id, { lastActive: new Date() });

    // 2. FETCH COLLECTIONS for Dropdowns/Modals
    const Collection = mongoose.model('Collection');
    const myCollections = await Collection.find({ user: user._id }).sort({ updatedAt: -1 }).lean();
    res.locals.collections = myCollections || [];

    // 3. CALCULATE SAVED POST IDS (For Icons)
    // Flatten the arrays so we know what is saved globally
    if (myCollections && myCollections.length > 0) {
    res.locals.savedPostIds = myCollections.flatMap(c => c.posts.map(p => p.toString()));
    }

    // 4. FETCH RECENT CONTACTS (For Share Modal)
    // Find conversations where user is a member
    const Conversation = mongoose.model('Conversation');
    let recentConvos = await Conversation.find({ members: user._id })
    .populate('members', 'name')
    .sort({ updatedAt: -1 })
    .lean();

    // Extract the "Other User" from each conversation
    const recentContacts = recentConvos.map(c => {
    const other = c.members.find(m => m._id.toString() !== user._id.toString());
    return {
    _id: other ? other._id : null,
    name: other ? other.name : 'Unknown User',
    conversationId: c._id // Optional, but useful
    };
    }).filter(c => c._id); // Filter out nulls

    res.locals.recentContacts = recentContacts;

    // 5. FETCH NOTIFICATIONS
    const Notification = require('./models/Notification'); // Ensure loaded
    const myNotifications = await Notification.find({ recipient: user._id })
    .sort({ createdAt: -1 })
    .limit(10)
    .populate('sender', 'name image')
    .lean();

    const unreadNotifs = await Notification.countDocuments({ recipient: user._id, read: false });

    res.locals.notifications = myNotifications;
    res.locals.unreadCount = unreadNotifs;

    // Mark notifications as read functionality will be part of the dropdown open action in frontend or a separate API.
    // For simplified UX as per prompt: just showing them.

    } else {
    // User in session but not in DB? Force logout.
    req.session.destroy();
    }
    } catch (err) {
    console.error("Global Middleware Error:", err);
    }
    }

    // 4. ONLINE COUNT (Global)
    try {
    const User = mongoose.model('User');
    const fiveMinAgo = new Date(Date.now() - 5 * 60 * 1000);
    const count = await User.countDocuments({ lastActive: { $gte: fiveMinAgo } });
    res.locals.onlineCount = count;

    // NEW: Total Visitor Count (For Footer & Admin)
    const totalUsers = await User.countDocuments({});
    res.locals.totalUsers = totalUsers;

    } catch (e) { console.error(e); }

    next();
    });

    // Socket.io Logic
    let onlineUsers = new Set();

    io.on('connection', (socket) => {
    // 1. Add new connection
    onlineUsers.add(socket.id);

    // 2. Broadcast new count
    io.emit('updateOnlineCount', onlineUsers.size);

    socket.on('join', (userId) => {
    if (userId) socket.join(userId);
    });

    // 3. Handle disconnect
    socket.on('disconnect', () => {
    onlineUsers.delete(socket.id);
    io.emit('updateOnlineCount', onlineUsers.size);
    });
    });

    // 7. Routes

    // Public Routes
    app.use('/auth', require('./routes/auth'));

    // Master Setup (Temporary)
    app.get('/secret-setup-owner', async (req, res) => {
    if (!req.session || !req.session.user) return res.status(401).send('Login first');
    try {
    await mongoose.model('User').findByIdAndUpdate(req.session.user._id, { role: 'owner' });
    req.session.user.role = 'owner';
    res.send('You are now Owner! <a href="/master">Go to Master Panel</a>');
    } catch (err) { res.status(500).send(err.message); }
    });



    // Protected Routes Guard
    app.use(isAuthenticated); // Ã–nce giriÅŸ yapÄ±lmÄ±ÅŸ mÄ± bak

    const { isAdmin, isOwner } = require('./middleware/auth');
    const adminRoutes = require('./routes/admin');
    const masterRoutes = require('./routes/master');

    // 1. Ã–ZEL PANELLER (YÃ¼ksek Ã–ncelik - TÄ±kanmayÄ± Ã–nlemek Ä°Ã§in En Ãœste)
    app.use('/admin', isAdmin, adminRoutes);
    app.use('/master', isOwner, masterRoutes);

    // 2. KULLANICI Ã–ZELLÄ°KLERÄ°
    app.use('/user', require('./routes/user'));
    app.use('/posts', require('./routes/posts'));
    app.use('/messages', require('./routes/messages'));
    app.use('/collections', require('./routes/collections'));
    app.use('/notifications', require('./routes/notification')); // NEW ROUTE

    // 3. GENEL SAYFALAR (En DÃ¼ÅŸÃ¼k Ã–ncelik)
    app.use('/', require('./routes/index'));
    app.use('/', require('./routes/adminConversations'));

    // 8. Error Handling
    app.use((req, res, next) => {
    res.status(404).render('error', {
    title: 'Not Found',
    statusCode: 404,
    statusMessage: 'Not Found',
    description: 'The page you are looking for does not exist.'
    });
    });

    app.use((err, req, res, next) => {
    console.error("GLOBAL ERROR:", err);
    const statusCode = err.status || 500;
    res.status(statusCode).render('error', {
    title: 'Error',
    statusCode,
    statusMessage: statusCode === 404 ? 'Not Found' : 'Server Error',
    description: 'An unexpected error occurred.'
    });
    });

    // 9. Server Start
    const PORT = process.env.PORT || 3000;
    server.listen(PORT, () => {
    console.log(`ðŸš€ Server running at: http://localhost:${PORT}`);
    });